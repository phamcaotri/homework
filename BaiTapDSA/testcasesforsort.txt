30: 7 28 16 9 18 23 21 11 26 25 2 13 29 14 15 10 19 6 17 24 27 8 3 20 4 22 5 12 1 30
40: 16 32 8 23 28 11 39 4 27 17 10 25 2 13 37 30 9 18 22 20 34 14 35 3 26 15 7 24 6 19 38 29 5 12 21 36 31 1 33 40
50: 29 43 41 23 47 16 28 11 39 32 10 25 35 18 17 37 49 45 27 13 33 15 36 24 38 42 30 46 48 44 31 26 14 34 40 22 12 19 21 20 8 9 4 6 7 5 3 2 1 50
50: 23 38 4 2 30 6 47 13 12 19 1 10 46 8 36 43 9 20 40 50 32 34 11 39 3 17 35 14 44 24 26 41 18 37 33 5 22 7 21 25 29 48 15 31 42 45 16 27 28 49
50: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2

        //auto start = high_resolution_clock::now();
        //auto stop = high_resolution_clock::now();
        //auto duration = duration_cast<nanoseconds>(stop - start);
        //cout << i << ", runtime: " << duration.count() << " ns" << '\n';

sort ranking: (50000)

SimpleSort: 11.1815s
BubbleSort 10.3523s
InterchangeSort 10.1037s
ShakeSort: 9.30935s
InsertionSort: 5.65721s
SelectionSort 3.68423s
HeapSort: 0.0158071s
MergeSort: 0.0169789s
QuickSortRP: 0.0075496s
QuickSort: 0.0072709s


class IArrayFunction {
public:
  virtual void inputArray() = 0;
  virtual void outputArray() = 0;
  virtual void randomArray() = 0;
};

class ArrayFunction : public IArrayFunction {
public:
  void inputArray() override { ... }
  void outputArray() override { ... }
  void randomArray() override { ... }
};

class ISortAnalyze {
public:
  virtual void countCompare() = 0;
  virtual void countSwap() = 0;
  virtual void countAccess() = 0;
};

class SortAnalyze : public ISortAnalyze {
public:
  void countCompare() override { ... }
  void countSwap() override { ... }
  void countAccess() override { ... }
};

class ITimeMeasure {
public:
  virtual void startTimer() = 0;
  virtual void stopTimer() = 0;
  virtual double getElapsedTime() = 0;
};

class TimeMeasure : public ITimeMeasure {
public:
  void startTimer() override { ... }
  void stopTimer() override { ... }
  double getElapsedTime() override { ... }
};

class Draw {
public:
  Draw(IArrayFunction* arrFunc, ISortAnalyze* sortAnalyze, ITimeMeasure* timeMeasure) :
    m_arrFunc(arrFunc), m_sortAnalyze(sortAnalyze), m_timeMeasure(timeMeasure) {}
  
  void drawSort() {
    m_arrFunc->randomArray();
    m_timeMeasure->startTimer();
    // Perform sorting algorithm
    m_timeMeasure->stopTimer();
    m_arrFunc->outputArray();
    std::cout << "Total compares: " << m_sortAnalyze->countCompare() << std::endl;
    std::cout << "Total swaps: " << m_sortAnalyze->countSwap() << std::endl;
    std::cout << "Total array accesses: " << m_sortAnalyze->countAccess() << std::endl;
    std::cout << "Total execution time: " << m_timeMeasure->getElapsedTime() << " seconds" << std::endl;
  }

private:
  IArrayFunction* m_arrFunc;
  ISortAnalyze* m_sortAnalyze;
  ITimeMeasure* m_timeMeasure;
};