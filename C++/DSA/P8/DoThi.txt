ĐỒ THỊ
Bài toán tô màu đồ thị
input:
    n : số lượng đỉnh
    một đồ thị G = (V, E) Đỉnh biểu diễn một quốc gia, cạnh biểu diễn mqh láng giềng
    bảng màu (mảng)
output:
    danh sách màu tương ứng với quốc gia

cách nhập đồ thị
    nhập 2 số v e, là số đỉnh số cạnh của đồ thị
    mỗi e dòng tiếp theo là một cặp số cho biết đỉnh đầu và đỉnh cuối của cạnh đó.
    nếu các đỉnh có tên thì dòng thứ 2 là v tên đỉnh

ma trận kề
    nếu ma trận có n đỉnh, thì ma trận là một ma trận vuông nxn
    dòng có index i lưu thông tin của đỉnh i
    ô của ma trận lưu quan hệ giữa 2 đỉnh

    nếu là đồ thị đa hoặc ma trận trọng số thì ô lưu số cạnh / trọng số

Duyệt đồ thị
Phương pháp để xét qua tất cả các đỉnh của đồ thị theo một nguyên tắc nhất định
có 2 cách duyệt:
    tìm kiếm theo chiều rộng
    tìm kiếm theo chiều sâu
        ưu tiên lựa chọn đi về phía đỉnh kề của nó trước.
        thống nhât: chọn đứa con được sinh ra sau cùng
        xử lý khi đi ngõ cụt: quay lui (backtraking)
        nếu quay lui về đỉnh gốc mà vẫn chưa tìm được đỉnh cần tìm thì kết luận không có đỉnh đó trong đồ thị

        cách cài đặt: dùng stack
            đưa đỉnh gốc vào stack
            lấy đỉnh đầu tiên ra khỏi stack
            xét các đỉnh kề của nó
            nếu đỉnh kề chưa được duyệt thì đưa vào stack
            lặp lại cho đến khi stack rỗng

            lưu ý: kiểm tra xem đỉnh kề có được duyệt chưa, nếu rồi thì không bỏ vào stack nữa
            B1:
                open = {s}
                close = {}
            B2:
                nếu open rỗng thì dừng
                p = open.pop()
                close.add(p)
            B3:
                xét các đỉnh kề của p
                nếu đỉnh kề chưa được duyệt thì đưa vào open
            B4:
                lặp lại B2

                    dùng kỹ thuật đệ quy quay lui (backtraking)
BFS

b1 khởi tạo:
    open = {s}
    close = {}

b2 while open != {}:
    lấu p từ đầu open (xoá p khỏi open)
    nếu p là đỉnh cần tìm:
        return p
    bỏ p vào close
    tìm các đỉnh kề với close vào open (chưa có trong close)
b3 nếu không tìm thấy:
    return None

khi thực hiện những giải thuật này cần lưu ý những tình huống xử lý đặc biệt.


BÀI TOÁN TÌM ĐƯỜNG ĐI NGẮN nhất

1. tìm đường đi ngắn nhất từ một đỉnh đến một đỉnh khác: có hướng, đơn đồ thị, có trọng số cạnh ( >= 0), đỉnh xuất phát, đỉnh đích. output. độ dài đường đi ngắn nhất
2. tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại
3. tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh. output: nC2 độ dài đường đi ngắn nhất giữa các cặp đỉnh

1.
thuật dijkstra

input: đồ thị có hướng, có trọng số cạnh, đỉnh xuất phát, đỉnh đích
output: độ dài đường đi ngắn nhất

b1 khởi tạo
open = {s}
close = {}
d[s] = 0

b2: while open != {}:
    lấy p từ đầu open (xoá p khỏi open) có d[p] nhỏ nhất
    nếu p là đỉnh đích:
        return d[p]
